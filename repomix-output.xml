
<directory_structure>
app/
  api/
    check-document/
      route.ts
  globals.css
  layout.tsx
  page.tsx
components/
  ModelSelector.tsx
  ResultsTable.tsx
  RulesInput.tsx
  UploadSection.tsx
lib/
  llm-checker.ts
  pdf-extractor.ts
  types.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
.gitignore
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/check-document/route.ts">
// app/api/check-document/route.ts

import { NextRequest, NextResponse } from "next/server";
import { checkAllRules } from "@/lib/llm-checker";
import { CheckResponse } from "@/lib/types";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Extract data
    const { pdfText, rules, model } = body;

    // Validate inputs
    if (!pdfText || typeof pdfText !== 'string') {
      return NextResponse.json(
        { success: false, error: "No PDF text provided", results: [] },
        { status: 400 }
      );
    }

    if (!rules || !Array.isArray(rules)) {
      return NextResponse.json(
        { success: false, error: "No rules provided", results: [] },
        { status: 400 }
      );
    }

    if (rules.length !== 3) {
      return NextResponse.json(
        { success: false, error: "Exactly 3 rules are required", results: [] },
        { status: 400 }
      );
    }

    for (const rule of rules) {
      if (typeof rule !== "string" || rule.trim().length === 0) {
        return NextResponse.json(
          { success: false, error: "All rules must be non-empty strings", results: [] },
          { status: 400 }
        );
      }
    }

    if (!model || typeof model !== 'string') {
      return NextResponse.json(
        { success: false, error: "No model selected", results: [] },
        { status: 400 }
      );
    }

    let truncatedText = pdfText;
    const maxLength = 8000;
    if (truncatedText.length > maxLength) {
      truncatedText = truncatedText.substring(0, maxLength) + "... [text truncated]";
    }

    const results = await checkAllRules(rules, truncatedText, model);

    const response: CheckResponse = {
      success: true,
      results: results,
      model: model,
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error("Error in check-document API:", error);
    
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : "Internal server error",
        results: []
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="components/ResultsTable.tsx">
// components/ResultsTable.tsx

"use client";

import { CheckResult } from "@/lib/types";
import { CheckCircle, XCircle, FileText } from "lucide-react";

interface ResultsTableProps {
  results: CheckResult[];
  model: string;
}

export default function ResultsTable({ results, model }: ResultsTableProps) {
  const passedCount = results.filter((r) => r.status === "pass").length;
  const totalCount = results.length;
  const overallScore = Math.round((passedCount / totalCount) * 100);

  const getConfidenceColor = (confidence: number): string => {
    if (confidence >= 80) return "text-green-400 bg-green-400/10";
    if (confidence >= 50) return "text-yellow-400 bg-yellow-400/10";
    return "text-red-400 bg-red-400/10";
  };

  const getConfidenceBorder = (confidence: number): string => {
    if (confidence >= 80) return "border-green-400/20";
    if (confidence >= 50) return "border-yellow-400/20";
    return "border-red-400/20";
  };

  return (
    <div className="bg-gray-800 border border-gray-700 rounded-lg p-6">
      {/* Header with Overall Score */}
      <div className="mb-6 p-4 bg-gradient-to-r from-purple-500/10 to-blue-500/10 border border-purple-500/20 rounded-lg">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-2xl font-bold text-white mb-1">Compliance Results</h3>
            <p className="text-sm text-gray-400">Model: {model.split("/")[1] || model}</p>
          </div>
          <div className="text-center">
            <div className="text-4xl font-bold text-white mb-1">
              {passedCount}/{totalCount}
            </div>
            <div className="text-sm text-gray-400">Rules Passed</div>
            <div className="mt-2 text-2xl font-bold text-purple-400">{overallScore}%</div>
          </div>
        </div>
      </div>

      {/* Results Table */}
      <div className="space-y-4">
        {results.map((result, index) => (
          <div
            key={index}
            className={`border-2 rounded-lg p-5 transition-all ${
              result.status === "pass"
                ? "border-green-500/30 bg-green-500/5"
                : "border-red-500/30 bg-red-500/5"
            }`}
          >
            {/* Rule & Status Header */}
            <div className="flex items-start justify-between mb-4">
              <div className="flex-1">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-xs font-semibold text-gray-400">
                    RULE {index + 1}
                  </span>
                </div>
                <h4 className="text-lg font-semibold text-white">{result.rule}</h4>
              </div>
              <div className="flex items-center gap-2 ml-4">
                {result.status === "pass" ? (
                  <>
                    <CheckCircle className="text-green-400" size={24} />
                    <span className="font-bold text-green-400 uppercase">Pass</span>
                  </>
                ) : (
                  <>
                    <XCircle className="text-red-400" size={24} />
                    <span className="font-bold text-red-400 uppercase">Fail</span>
                  </>
                )}
              </div>
            </div>

            {/* Evidence */}
            <div className="mb-3">
              <div className="flex items-center gap-2 mb-2">
                <FileText className="text-blue-400" size={16} />
                <span className="text-xs font-semibold text-gray-400 uppercase">
                  Evidence
                </span>
              </div>
              <p className="text-sm text-gray-300 bg-gray-900/50 p-3 rounded border border-gray-700 italic">
                "{result.evidence}"
              </p>
            </div>

            {/* Reasoning & Confidence */}
            <div className="flex items-start justify-between gap-4">
              <div className="flex-1">
                <span className="text-xs font-semibold text-gray-400 uppercase block mb-1">
                  Reasoning
                </span>
                <p className="text-sm text-gray-300">{result.reasoning}</p>
              </div>
              <div className="text-right">
                <span className="text-xs font-semibold text-gray-400 uppercase block mb-1">
                  Confidence
                </span>
                <div
                  className={`px-4 py-2 rounded-lg border font-bold text-lg ${getConfidenceColor(
                    result.confidence
                  )} ${getConfidenceBorder(result.confidence)}`}
                >
                  {result.confidence}%
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="components/RulesInput.tsx">
// components/RulesInput.tsx

"use client";

import { CheckCircle2 } from "lucide-react";

interface RulesInputProps {
  rules: [string, string, string];
  onRulesChange: (rules: [string, string, string]) => void;
}

const EXAMPLE_RULES = [
  "The document must have a purpose section",
  "The document must mention at least one date",
  "The document must define at least one term",
];

export default function RulesInput({ rules, onRulesChange }: RulesInputProps) {
  const handleRuleChange = (index: number, value: string) => {
    const newRules: [string, string, string] = [...rules] as [string, string, string];
    newRules[index] = value;
    onRulesChange(newRules);
  };

  return (
    <div className="bg-gray-800 border border-gray-700 rounded-lg p-6">
      <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
        <CheckCircle2 className="text-green-400" size={20} />
        Define 3 Compliance Rules
      </h3>

      <div className="space-y-4">
        {rules.map((rule, index) => (
          <div key={index}>
            <label
              htmlFor={`rule-${index}`}
              className="block text-sm font-medium text-gray-300 mb-2"
            >
              Rule {index + 1}
            </label>
            <input
              id={`rule-${index}`}
              type="text"
              value={rule}
              onChange={(e) => handleRuleChange(index, e.target.value)}
              placeholder={EXAMPLE_RULES[index]}
              className="w-full px-4 py-3 bg-gray-900 border border-gray-600 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition-all"
            />
          </div>
        ))}
      </div>

      <div className="mt-4 p-3 bg-purple-500/10 border border-purple-500/20 rounded-lg">
        <p className="text-sm text-purple-300">
          ðŸ’¡ <strong>Examples:</strong> "Must mention a date", "Must define terms", "Must list requirements"
        </p>
      </div>
    </div>
  );
}
</file>

<file path="components/UploadSection.tsx">
// components/UploadSection.tsx

"use client";

import { Upload, FileText, X } from "lucide-react";
import { validatePDF } from "@/lib/pdf-extractor";

interface UploadSectionProps {
  file: File | null;
  onFileChange: (file: File | null) => void;
  error: string | null;
  setError: (error: string | null) => void;
}

export default function UploadSection({ file, onFileChange, error, setError }: UploadSectionProps) {
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    setError(null);

    if (!selectedFile) {
      onFileChange(null);
      return;
    }

    // Validate PDF
    const validation = validatePDF(selectedFile);
    if (!validation.valid) {
      setError(validation.error || "Invalid PDF file");
      onFileChange(null);
      return;
    }

    onFileChange(selectedFile);
  };

  const handleRemoveFile = () => {
    onFileChange(null);
    setError(null);
  };

  return (
    <div className="bg-gray-800 border border-gray-700 rounded-lg p-6">
      <h3 className="text-lg font-semibold text-white mb-4 flex items-center gap-2">
        <Upload className="text-blue-400" size={20} />
        Upload PDF Document
      </h3>

      {!file ? (
        <div>
          <label
            htmlFor="pdf-upload"
            className="flex flex-col items-center justify-center w-full h-40 border-2 border-dashed border-gray-600 rounded-lg cursor-pointer hover:border-blue-500 hover:bg-gray-700/50 transition-all"
          >
            <div className="flex flex-col items-center justify-center pt-5 pb-6">
              <FileText className="text-gray-400 mb-3" size={40} />
              <p className="mb-2 text-sm text-gray-400">
                <span className="font-semibold text-blue-400">Click to upload</span> or drag and drop
              </p>
              <p className="text-xs text-gray-500">PDF files only (max 10MB)</p>
            </div>
            <input
              id="pdf-upload"
              type="file"
              accept="application/pdf"
              onChange={handleFileChange}
              className="hidden"
            />
          </label>
        </div>
      ) : (
        <div className="flex items-center justify-between p-4 bg-gray-700/50 border border-gray-600 rounded-lg">
          <div className="flex items-center gap-3">
            <FileText className="text-blue-400" size={24} />
            <div>
              <p className="font-medium text-white">{file.name}</p>
              <p className="text-sm text-gray-400">
                {(file.size / 1024).toFixed(2)} KB
              </p>
            </div>
          </div>
          <button
            onClick={handleRemoveFile}
            className="p-2 hover:bg-gray-600 rounded-lg transition-colors"
            aria-label="Remove file"
          >
            <X className="text-gray-400" size={20} />
          </button>
        </div>
      )}

      {error && (
        <div className="mt-4 p-3 bg-red-500/10 border border-red-500/20 rounded-lg">
          <p className="text-sm text-red-400">{error}</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="lib/pdf-extractor.ts">
// lib/client-pdf-extractor.ts


export async function extractPDFTextClient(file: File): Promise<string> {
  if (typeof window === 'undefined') {
    throw new Error('extractPDFTextClient can only be called on the client side');
  }

  try {
    const pdfjsLib = await import('pdfjs-dist');
    
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@${pdfjsLib.version}/build/pdf.worker.min.mjs`;
    
    const arrayBuffer = await file.arrayBuffer();
    const uint8Array = new Uint8Array(arrayBuffer);
    
    const loadingTask = pdfjsLib.getDocument({ data: uint8Array });
    const pdf = await loadingTask.promise;
    
    let fullText = '';
    
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      
      const pageText = textContent.items
        .map((item: any) => {
          if ('str' in item) {
            return item.str;
          }
          return '';
        })
        .join(' ');
      
      fullText += pageText + '\n\n';
    }
    
    if (!fullText || fullText.trim().length === 0) {
      throw new Error("PDF contains no extractable text");
    }

    const cleanText = fullText
      .replace(/\s+/g, " ")
      .replace(/\n+/g, "\n")
      .trim();

    return cleanText;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to extract PDF text: ${error.message}`);
    }
    throw new Error("Failed to extract PDF text: Unknown error");
  }
}


export function validatePDF(file: File): { valid: boolean; error?: string } {
  if (file.type !== "application/pdf") {
    return { valid: false, error: "File must be a PDF" };
  }

  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    return { valid: false, error: "PDF must be smaller than 10MB" };
  }

  if (file.size === 0) {
    return { valid: false, error: "PDF file is empty" };
  }

  return { valid: true };
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>


<file path="app/layout.tsx">
// app/layout.tsx

import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "DocuCheck AI - Document Compliance Checker",
  description: "AI-powered document compliance validation. Upload PDFs and check them against custom rules using advanced language models.",
  keywords: ["document compliance", "PDF checker", "AI validation", "document analysis"],
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
// app/page.tsx

"use client";

import { useState } from "react";
import { CheckResult, AVAILABLE_MODELS } from "@/lib/types";
import { extractPDFTextClient } from "@/lib/pdf-extractor";
import UploadSection from "@/components/UploadSection";
import RulesInput from "@/components/RulesInput";
import ModelSelector from "@/components/ModelSelector";
import ResultsTable from "@/components/ResultsTable";
import { Play, Loader2 } from "lucide-react";

export default function Home() {
  const [file, setFile] = useState<File | null>(null);
  const [rules, setRules] = useState<[string, string, string]>(["", "", ""]);
  const [selectedModel, setSelectedModel] = useState<string>(AVAILABLE_MODELS[0].id);
  const [results, setResults] = useState<CheckResult[] | null>(null);
  const [modelUsed, setModelUsed] = useState<string>("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [uploadError, setUploadError] = useState<string | null>(null);

  const handleCheckDocument = async () => {
   
    setError(null);
    setResults(null);

    if (!file) {
      setError("Please upload a PDF file");
      return;
    }

    const emptyRules = rules.filter((rule) => rule.trim() === "");
    if (emptyRules.length > 0) {
      setError("Please fill in all 3 rules");
      return;
    }

    setLoading(true);

    try {
      console.log("Extracting text from PDF...");
      const pdfText = await extractPDFTextClient(file);
      console.log("Extracted text length:", pdfText.length);

      // Step 2: Send to API as JSON
      console.log("Sending to API...");
      const response = await fetch("/api/check-document", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          pdfText: pdfText,
          rules: rules,
          model: selectedModel,
        }),
      });

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || "Failed to check document");
      }

      setResults(data.results);
      setModelUsed(data.model);
    } catch (err) {
      console.error("Error checking document:", err);
      setError(err instanceof Error ? err.message : "An error occurred");
    } finally {
      setLoading(false);
    }
  };

  const isFormValid = file !== null && rules.every((rule) => rule.trim() !== "");

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900">
      <div className="container mx-auto px-4 py-12 max-w-7xl">
        {/* Header */}
        <div className="text-center mb-12">
          <h1 className="text-5xl font-bold text-white mb-4 bg-gradient-to-r from-purple-400 to-blue-400 bg-clip-text text-transparent">
            DocuCheck AI
          </h1>
          <p className="text-xl text-gray-400 max-w-2xl mx-auto">
            AI-powered document compliance checker. Upload a PDF, define your rules, and let AI validate your document.
          </p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
          <div className="lg:col-span-2 space-y-6">
            <UploadSection
              file={file}
              onFileChange={setFile}
              error={uploadError}
              setError={setUploadError}
            />

            <RulesInput rules={rules} onRulesChange={setRules} />
          </div>

          <div>
            <ModelSelector selectedModel={selectedModel} onModelChange={setSelectedModel} />
          </div>
        </div>

        {/* Check Button */}
        <div className="flex justify-center mb-8">
          <button
            onClick={handleCheckDocument}
            disabled={!isFormValid || loading}
            className={`px-8 py-4 rounded-lg font-semibold text-lg flex items-center gap-3 transition-all transform ${
              isFormValid && !loading
                ? "bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-500 hover:to-blue-500 text-white shadow-lg hover:shadow-xl hover:scale-105"
                : "bg-gray-700 text-gray-400 cursor-not-allowed"
            }`}
          >
            {loading ? (
              <>
                <Loader2 className="animate-spin" size={24} />
                Analyzing Document...
              </>
            ) : (
              <>
                <Play size={24} />
                Check Document
              </>
            )}
          </button>
        </div>

        {error && (
          <div className="mb-8 p-4 bg-red-500/10 border border-red-500/20 rounded-lg">
            <p className="text-red-400 text-center font-medium">{error}</p>
          </div>
        )}

        {results && <ResultsTable results={results} model={modelUsed} />}

        {/* Loading Skeleton */}
        {loading && (
          <div className="bg-gray-800 border border-gray-700 rounded-lg p-8">
            <div className="animate-pulse space-y-4">
              <div className="h-6 bg-gray-700 rounded w-1/3"></div>
              <div className="h-4 bg-gray-700 rounded w-2/3"></div>
              <div className="h-4 bg-gray-700 rounded w-1/2"></div>
            </div>
          </div>
        )}

        {/* Footer */}
        <div className="mt-12 text-center text-gray-500 text-sm">
          <p>Built with Next.js, OpenRouter API, and Tailwind CSS</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/ModelSelector.tsx">
// components/ModelSelector.tsx

"use client";

import { AVAILABLE_MODELS, LLMModel } from "@/lib/types";
import { Brain } from "lucide-react";

interface ModelSelectorProps {
  selectedModel: string;
  onModelChange: (model: string) => void;
}

export default function ModelSelector({ selectedModel, onModelChange }: ModelSelectorProps) {
  return (
    <div className="bg-gray-800 border border-gray-700 rounded-lg p-6">
      <div className="flex items-center gap-2 mb-4">
        <Brain className="text-purple-400" size={20} />
        <h3 className="text-lg font-semibold text-white">Select AI Model</h3>
      </div>
      
      <div className="space-y-3">
        {AVAILABLE_MODELS.map((model: LLMModel) => (
          <label
            key={model.id}
            className={`flex items-center justify-between p-4 rounded-lg border-2 cursor-pointer transition-all ${
              selectedModel === model.id
                ? "border-purple-500 bg-purple-500/10"
                : "border-gray-700 bg-gray-800/50 hover:border-gray-600"
            }`}
          >
            <div className="flex items-center gap-3">
              <input
                type="radio"
                name="model"
                value={model.id}
                checked={selectedModel === model.id}
                onChange={(e) => onModelChange(e.target.value)}
                className="w-4 h-4 text-purple-500 focus:ring-purple-500 focus:ring-2"
              />
              <div>
                <div className="font-medium text-white">{model.name}</div>
                <div className="text-sm text-gray-400">{model.provider}</div>
              </div>
            </div>
           
          </label>
        ))}
      </div>

      
    </div>
  );
}
</file>

<file path="lib/llm-checker.ts">
// lib/llm-checker.ts

import { CheckResult } from "./types";


const SYSTEM_PROMPT = `You are a precise document compliance checker. Your task is to analyze document text and determine if it meets specific rules.

CRITICAL INSTRUCTIONS:
1. Respond ONLY with valid JSON, no markdown, no code blocks, no preamble
2. Be strict but fair - only pass if clear evidence exists
3. Extract exact sentences from the document as evidence
4. Keep reasoning concise (max 20 words)
5. Confidence score should reflect certainty (0-100)

Response format:
{
  "status": "pass" or "fail",
  "evidence": "exact sentence from document that proves your decision",
  "reasoning": "brief explanation in max 20 words",
  "confidence": number between 0 and 100
}`;


function constructUserPrompt(rule: string, documentText: string): string {
  // console.log("hello " ,documentText)
  return `RULE TO CHECK: "${rule}"

DOCUMENT TEXT:
${documentText}

Analyze the document and determine if it meets the rule. Respond with JSON only.`;
}

export async function checkRuleWithLLM(
  rule: string,
  documentText: string,
  model: string
): Promise<CheckResult> {
  const apiKey = process.env.OPENROUTER_API_KEY;

  if (!apiKey) {
    throw new Error("OPENROUTER_API_KEY is not configured");
  }

  try {
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "HTTP-Referer": process.env.NEXT_PUBLIC_SITE_URL || "http://localhost:3000",
        "X-Title": "DocuCheck AI",
      },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: SYSTEM_PROMPT },
          { role: "user", content: constructUserPrompt(rule, documentText) },
        ],
        temperature: 0.3,
        max_tokens: 500,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`OpenRouter API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    const messageContent = data.choices?.[0]?.message?.content?.trim();

    if (!messageContent) {
      throw new Error("No response from LLM");
    }

    const cleaned = messageContent
      .replace(/```json/g, "")
      .replace(/```/g, "")
      .trim();

    const parsed = JSON.parse(cleaned);

    return {
      rule,
      status: parsed.status?.toLowerCase() === "pass" ? "pass" : "fail",
      evidence: parsed.evidence || "No evidence provided",
      reasoning: parsed.reasoning || "No reasoning provided",
      confidence: Math.min(Math.max(parsed.confidence || 0, 0), 100),
    };

  } catch (error) {
    console.error("Error checking rule with LLM:", error);

    return {
      rule,
      status: "fail",
      evidence: "Error occurred during analysis",
      reasoning: error instanceof Error ? error.message : "Unknown error",
      confidence: 0,
    };
  }
}


export async function checkAllRules(
  rules: string[],
  documentText: string,
  model: string
): Promise<CheckResult[]> {
  // Check all rules in parallel for better performance
  const results = await Promise.all(
    rules.map((rule) => checkRuleWithLLM(rule, documentText, model))
  );

  return results;
}
</file>

<file path="lib/types.ts">
// lib/types.ts

export interface CheckResult {
  rule: string;
  status: "pass" | "fail";
  evidence: string;
  reasoning: string;
  confidence: number;
}

export interface CheckRequest {
  pdfText: string;
  rules: string[];
  model: string;
}

export interface CheckResponse {
  results: CheckResult[];
  model: string;
  success: boolean;
  error?: string;
}

export interface LLMModel {
  id: string;
  name: string;
  provider: string;
  free: boolean;
}
export const AVAILABLE_MODELS: LLMModel[] = [
  {
    id: "google/gemini-2.5-flash",
    name: "Gemini 2.5 Flash",
    provider: "Google",
    free: true,
  },
  {
    id: "anthropic/claude-3.5-sonnet",
    name: "Claude 3.5 Sonnet",
    provider: "Anthropic",
    free: false,
  },

  {
    id: "openai/gpt-4.1",
    name: "GPT-4.1",
    provider: "OpenAI",
    free: false,
  }
];
</file>

<file path="package.json">
{
  "name": "docucheck-ai",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@types/pdf-parse": "^1.1.5",
    "lucide-react": "^0.554.0",
    "next": "16.0.3",
    "pdf-parse": "^2.4.5",
    "pdfjs-dist": "^5.4.394",
    "react": "19.2.0",
    "react-dom": "19.2.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>
